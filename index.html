<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Tetris</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #111;
      font-family: 'Segoe UI', sans-serif;
      height: 100vh; width: 100vw;
      display: flex; 
      justify-content: center; 
      align-items: center;
      overflow: hidden; /* Prevent scrollbars */
    }
    .tetris-container {
      background: #1c1c1c;
      border-radius: 1rem;
      padding: 1rem;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 95vw; 
      height: 95vh;
      max-width: 100vw;
      box-sizing: border-box;
    }
    canvas {
      background: #111;
      border: 2px solid #444;
      border-radius: 0.5rem;
      margin: 0.5rem;
      height: 80vh; /* Taller canvas */
      aspect-ratio: 1/2;
    }
    .scoreboard {
      display: flex; 
      gap: 2rem; 
      color: #fff;
      margin: 0.5rem; 
      font-size: calc(1.5vw + 0.5rem);
      flex-wrap: wrap;
      justify-content: center;
    }
    #startBtn {
      padding: 0.8rem 2rem;
      background: #333; 
      color: #fff;
      border: none; 
      border-radius: 0.4rem;
      cursor: pointer; 
      font-size: calc(1vw + 0.5rem);
      margin: 0.5rem;
    }
    #startBtn:hover { 
      background: #555; 
    }
    .overlay {
      position: fixed;
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff; 
      padding: 2rem 3rem;
      border-radius: 1rem; 
      font-size: calc(2vw + 1rem);
      z-index: 10; 
      display: none;
    }
    h2 {
      color: white; 
      margin: 0.5rem;
      font-size: calc(2vw + 1rem);
    }
    .controls {
      color: #888;
      font-size: calc(0.8vw + 0.3rem);
      text-align: center;
      margin: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="tetris-container">
    <h2>Tetris</h2>
    <canvas id="tetris"></canvas>
    <div class="scoreboard">
      <span>Score: <span id="score">0</span></span>
      <span>Lines: <span id="lines">0</span></span>
      <span>Level: <span id="level">1</span></span>
    </div>
    <button id="startBtn">Start</button>
    <div class="controls">
      ← → : Move | ↑ : Rotate | ↓ : Drop<br>
      Space: Hard Drop | P: Pause | Tab: Blank Screen
    </div>
    <div id="pauseOverlay" class="overlay">Paused</div>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const ROWS = 20, COLS = 10;
    const COLORS = ["#0ff","#f00","#ff0","#0f0","#00f","#f0f","#fa0"];
    const SHAPES = [
      [[1,1,1,1]],
      [[2,2,2],[0,2,0]],
      [[3,3,0],[0,3,3]],
      [[0,4,4],[4,4,0]],
      [[5,5,5],[5,0,0]],
      [[6,6,6],[0,0,6]],
      [[7,7],[7,7]]
    ];

    let board, piece, next, score, lines, level, dropInterval, gameOver, paused, animId, BLOCK = 24;
    const scoreEl = document.getElementById('score');
    const linesEl = document.getElementById('lines');
    const levelEl = document.getElementById('level');
    const startBtn = document.getElementById('startBtn');
    const pauseOverlay = document.getElementById('pauseOverlay');

    function resetGame() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      score = 0; lines = 0; level = 1;
      dropInterval = 600; gameOver = false; paused = false;
      next = randomPiece(); spawn(); updateScore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      board.forEach((row, y) => row.forEach((v, x) => v && drawBlock(x, y, v)));
      piece.shape.forEach((r, dy) => r.forEach((v, dx) => v && drawBlock(piece.x + dx, piece.y + dy, v)));
    }

    function drawBlock(x, y, val) {
      ctx.fillStyle = COLORS[val - 1];
      ctx.fillRect(x * BLOCK + 1, y * BLOCK + 1, BLOCK - 2, BLOCK - 2);
    }

    function randomPiece() {
      let i = Math.floor(Math.random() * SHAPES.length);
      return {shape: SHAPES[i].map(r => [...r]), x: 3, y: 0, type: i + 1};
    }

    function spawn() {
      piece = next || randomPiece();
      piece.x = 3; piece.y = 0;
      next = randomPiece();
      if (collide(0, 0, piece.shape)) {
        gameOver = true; 
        cancelAnimationFrame(animId);
        setTimeout(() => alert("Game Over"), 100);
      }
    }

    function collide(dx, dy, shape) {
      return shape.some((row, y) => row.some((v, x) =>
        v && (
          board[y + piece.y + dy]?.[x + piece.x + dx] ||
          x + piece.x + dx < 0 ||
          x + piece.x + dx >= COLS ||
          y + piece.y + dy >= ROWS
        )));
    }

    function merge() {
      piece.shape.forEach((r, dy) => r.forEach((v, dx) => {
        if (v && piece.y + dy >= 0) board[piece.y + dy][piece.x + dx] = v;
      }));
    }

    function rotate(mat) {
      return mat[0].map((_, i) => mat.map(r => r[i]).reverse());
    }

    function drop() {
      if (gameOver || paused) return;
      if (!collide(0, 1, piece.shape)) piece.y++;
      else { merge(); clearLines(); spawn(); }
      draw();
    }

    function hardDrop() { while (!collide(0, 1, piece.shape)) piece.y++; drop(); }
    function move(dir) { if (!collide(dir, 0, piece.shape)) piece.x += dir; }
    function turn() {
      let rot = rotate(piece.shape);
      if (!collide(0, 0, rot)) piece.shape = rot;
    }

    function clearLines() {
      let count = 0;
      board = board.filter(r => !r.every(v => v));
      count = ROWS - board.length;
      while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
      if (count) {
        score += [0, 40, 100, 300, 1200][count] * level;
        lines += count;
        level = 1 + Math.floor(lines / 10);
        dropInterval = Math.max(100, 600 - level * 50);
        updateScore();
      }
    }

    function updateScore() {
      scoreEl.textContent = score;
      linesEl.textContent = lines;
      levelEl.textContent = level;
    }

    let last = 0, dropAcc = 0;
    function update(now = 0) {
      if (gameOver) return;
      let dt = now - last; last = now;
      if (!paused) {
        dropAcc += dt;
        if (dropAcc > dropInterval) {
          drop(); dropAcc = 0;
        }
        draw();
      }
      animId = requestAnimationFrame(update);
    }

    function resizeCanvas() {
      // Calculate the best size that maintains aspect ratio and fills the container
      const container = canvas.parentElement;
      const containerHeight = container.clientHeight * 0.8; // 80% of container height
      const containerWidth = container.clientWidth * 0.9;  // 90% of container width
      
      // Calculate dimensions maintaining 1:2 aspect ratio
      let width = Math.min(containerWidth, containerHeight / 2);
      let height = width * 2;
      
      canvas.width = width;
      canvas.height = height;
      BLOCK = Math.floor(width / COLS);
      draw();
    }

    window.addEventListener('resize', resizeCanvas);
    
    document.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        e.preventDefault(); // Prevent default tab behavior
        document.body.innerHTML = ''; // Blank the page
        return;
      }
      
      if (gameOver || paused) return;
      switch (e.key) {
        case "ArrowLeft": move(-1); break;
        case "ArrowRight": move(1); break;
        case "ArrowDown": drop(); break;
        case "ArrowUp": turn(); break;
        case " ": hardDrop(); break;
      }
      draw();
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'p' || e.key === 'P') {
        paused = !paused;
        pauseOverlay.style.display = paused ? 'block' : 'none';
        if (!paused) update(); else cancelAnimationFrame(animId);
      }
    });

    startBtn.onclick = () => {
      resetGame(); 
      resizeCanvas();
      cancelAnimationFrame(animId);
      last = performance.now(); 
      dropAcc = 0;
      update(); 
      pauseOverlay.style.display = 'none';
    }

    // Initialize the game
    resetGame(); 
    resizeCanvas(); 
    draw();
  </script>
</body>
</html>
